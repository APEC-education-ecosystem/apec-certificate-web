/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimCertInstruction,
  type ParsedCreateCertProofInstruction,
  type ParsedCreateCourseInstruction,
  type ParsedEnrollCourseInstruction,
  type ParsedInitProviderInstruction,
} from '../instructions';

export const APEC_CERT_PROGRAM_ADDRESS =
  'CAxe8JydEaRrtF3DVdPATw9XwAgYZUnCJ4wr5ZbvUFMp' as Address<'CAxe8JydEaRrtF3DVdPATw9XwAgYZUnCJ4wr5ZbvUFMp'>;

export enum ApecCertAccount {
  CertProof,
  Course,
  Provider,
}

export function identifyApecCertAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): ApecCertAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([82, 4, 192, 74, 105, 190, 230, 170])
      ),
      0
    )
  ) {
    return ApecCertAccount.CertProof;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([206, 6, 78, 228, 163, 138, 241, 106])
      ),
      0
    )
  ) {
    return ApecCertAccount.Course;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([164, 180, 71, 17, 75, 216, 80, 195])
      ),
      0
    )
  ) {
    return ApecCertAccount.Provider;
  }
  throw new Error(
    'The provided account could not be identified as a apecCert account.'
  );
}

export enum ApecCertInstruction {
  ClaimCert,
  CreateCertProof,
  CreateCourse,
  EnrollCourse,
  InitProvider,
}

export function identifyApecCertInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): ApecCertInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([70, 145, 102, 143, 36, 10, 200, 208])
      ),
      0
    )
  ) {
    return ApecCertInstruction.ClaimCert;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([148, 164, 197, 242, 186, 33, 65, 18])
      ),
      0
    )
  ) {
    return ApecCertInstruction.CreateCertProof;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([120, 121, 154, 164, 107, 180, 167, 241])
      ),
      0
    )
  ) {
    return ApecCertInstruction.CreateCourse;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([99, 88, 16, 143, 40, 253, 22, 47])
      ),
      0
    )
  ) {
    return ApecCertInstruction.EnrollCourse;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([118, 169, 91, 206, 83, 110, 185, 107])
      ),
      0
    )
  ) {
    return ApecCertInstruction.InitProvider;
  }
  throw new Error(
    'The provided instruction could not be identified as a apecCert instruction.'
  );
}

export type ParsedApecCertInstruction<
  TProgram extends string = 'CAxe8JydEaRrtF3DVdPATw9XwAgYZUnCJ4wr5ZbvUFMp',
> =
  | ({
      instructionType: ApecCertInstruction.ClaimCert;
    } & ParsedClaimCertInstruction<TProgram>)
  | ({
      instructionType: ApecCertInstruction.CreateCertProof;
    } & ParsedCreateCertProofInstruction<TProgram>)
  | ({
      instructionType: ApecCertInstruction.CreateCourse;
    } & ParsedCreateCourseInstruction<TProgram>)
  | ({
      instructionType: ApecCertInstruction.EnrollCourse;
    } & ParsedEnrollCourseInstruction<TProgram>)
  | ({
      instructionType: ApecCertInstruction.InitProvider;
    } & ParsedInitProviderInstruction<TProgram>);
